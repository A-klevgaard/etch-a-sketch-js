<!--TO DO
1) PRETTY MUCH DONE. WOULD PREFER TO FIX THE RADIO BUTTON EVENT HANDLER SO THAT IT JUST CHECKS TO SEE WHICH BUTTON IS CURRENTLY CHECKED, AND NOT
ON THE CHANGE, BECAUSE THIS LEADS TO SOME ISSUES DURING PAGE REFRESH.
2)NOT REQUIRED, BUT I MIGHT DO SOME MINOR COSMETIC TOUCHUPS WITH THE BUTTONS / SKETCHBOX. JUST TO MAKE THINGS LOOK A BIT NICER.
-->
<!DOCTYPE html>
<html>
<head>
  <title>Etch-a-Sketch-in-js</title>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width", initial-scale="1.0">
  <link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>

    <div id="title-block">
    <h1>Etch-a-Sketch</h1>
    </div>

    <div id="controls-container">
      <div id="controls">
        <button type="button" id="new-grid-button" onclick="customGrid(); return false">Make a New Grid</button>
        <div id="mode-group">
          <label class="control-label" for="black-white"><input type="radio" id="black-white" class="mode" name="mode" value="1" checked="true"> Black</label>
          <label class="control-label" for="dimmer"><input type="radio" id="dimmer" class="mode" name="mode" value="2"> Dimmer</label>
          <label class="control-label" for="color-rdm"><input type="radio" id="color-rdm" class="mode" name="mode" value="3"> Random Color</label>
        </div> <!--End mode-group-->
        <button type="button" id="clear-grid-button" onclick="clearGrid(); return false">Clear the Grid</button>
      </div><!--End controls-->
    </div><!--End controls-container-->

    <!--The etch a sketch grid will be populated with javascript-->
    <div id="grid-container">
    <div id="sketch-container"></div>
    </div>

  
  <script>
    let sketchMode = "1"; //global variable used to store what the current sketch mode is. Controlled by page radio buttons

//*************************************************************************************************************
//Functions used to create and manipulate the etch a sketch grid
//*************************************************************************************************************
    //*************************************************************************************************************
    //Creates the grid for the etch a sketch
    function makeGrid(SideL) {
      const container = document.querySelector('#sketch-container');
      container.style.gridTemplateColumns = `repeat(${SideL}, ${100/SideL}%)`
      container.style.gridTemplateRows = `repeat(${SideL}, ${100/SideL}%)`
      for (let i = 0; i < (SideL*SideL); i++ ) {
      let mkDiv = document.createElement('div');
      mkDiv.setAttribute("class", "sketch-pixel");
      container.appendChild(mkDiv);
      }
    }
    //*************************************************************************************************************
    //removes the grid from the etch a sketch
    function removeGrid() {
      const container = document.querySelector('#sketch-container');
      while (container.firstChild) {
        container.removeChild(container.lastChild);
      }

    }
    //*************************************************************************************************************
    //makes a grid with a user specified side length
    function customGrid() {
      let sideLength = prompt("Enter the amount of pixels on the new grid's side...")

      //type check to ensure user enters a valid number
      if (+sideLength === parseInt(sideLength)) {

        //delete replace the previous grid with a new one and refresh the event handler for the new grid
        removeGrid();        
        makeGrid((sideLength));
        eventRefresh();
      }
      else {
        alert("That is not a valid number.");
      }
    }

    //*************************************************************************************************************
    //clears out the whole grid
    function clearGrid() {
    let pixelGrid = document.querySelectorAll('.sketch-pixel');
      //iterates through the node list and removes all dynamic coloring classes
      pixelGrid.forEach((pixel) => {
        pixel.classList.remove("darkerEveryHover");
        pixel.classList.remove("randomColor");
        pixel.classList.remove("on-pixel");
        pixel.style.backgroundColor = "";
      });
    }
    //*************************************************************************************************************
    //simple function to get an intger from between 2 numbers
    function randomIntFromInterval(min, max) { 
    return Math.floor(Math.random() * (max - min + 1) + min);
}

  //*************************************************************************************************************
  //Event handlers
  //*************************************************************************************************************
  //*************************************************************************************************************
  //attaches new event listeners to each cell in the new grid
  function eventRefresh() {
      //event handlers used to control the etch a sketch
      let pixelGrid = document.querySelectorAll('.sketch-pixel');
      //iterates through the node list and checks to see if the mouse has entered a pixel
      pixelGrid.forEach((pixel) => {
        pixel.addEventListener('mouseenter', () => {
          //if "black" radio button is selected then this mode simply turns pixels off and on.
          if (sketchMode == "1") {
          //three rules below allow "black" to overwrite over dimmer and random color
          pixel.classList.remove("darkerEveryHover");
          pixel.classList.remove("randomColor");
          pixel.style.backgroundColor = "";

          pixel.classList.toggle("on-pixel");
          }

          //if "dimmer" radio button is selected, then everytime the mouse hovers over the cell it gets 10% darker
          else if (sketchMode === "2") {
            if (!pixel.classList.contains("darkerEveryHover")){
              pixel.classList.add("darkerEveryHover");
            }
              else {
                //getComputedStyle is a read only function, so 2 variables are needed to acquire the css rule for background color rgb values
                let style = getComputedStyle(pixel);
                let backgroundColor = style.backgroundColor;
                //takes the css rgb values for background and puts their string values into an array
                let currentRGBValues = backgroundColor.slice(4,backgroundColor.length -1);
                currentRGBValues = currentRGBValues.split(", ");
                //creates a stepdown value that is 25 units darker in rgb values than the current rgb values
                let nextDarkerStep = parseInt(currentRGBValues[0] -25);
                //updates the background color css rule with the new rgb value
                pixel.style.backgroundColor = `rgb(${nextDarkerStep},${nextDarkerStep},${nextDarkerStep}`;
              }
            }
          //if "Random Color" radio button is selected every cell the mouse moves over gets a new random color
          else if (sketchMode === "3") {
            pixel.style.backgroundColor = "";
            pixel.classList.add("randomColor");
            //pixel.style.backgroundColor = `rgb(${Math.ceil(Math.random*255)},${Math.ceil(Math.random*255)},${Math.ceil(Math.random*255)}`;
            //pixel.style.backgroundColor = `rgb(${Math.ceil(Math.random*255)},${Math.ceil(Math.random*255)},${Math.ceil(Math.random*255)}`;
            pixel.style.backgroundColor = `rgb(${randomIntFromInterval(0,255)},${randomIntFromInterval(0,255)},${randomIntFromInterval(0,255)})`;
            console.log("This should make a random color");
            
          }
          //^^^^^for some reason the above mode activates the sketchmode 1 events instead of 3. need to figure out why.
          
        });
      });
  }
  //*************************************************************************************************************
  //listens to see if the user selects a different drawing mode
  let radioButtons = document.querySelectorAll('.mode');
  radioButtons.forEach((radio) => {
    radio.addEventListener('change', () => {
      sketchMode = radio.value;
      console.log(sketchMode, typeof(sketchMode)); });
  });

    //upon page load populates the webpage with a 4x4 grad  
    makeGrid(4);
    eventRefresh();
  </script>
</body>
</html>